# Auxiliary functions for custom build system
# Copyright (c) 2002 Serge van den Boom
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

BUILDLOG=/tmp/build.log
TEMPFILE="/tmp/build.$$.tmp"

# Description: prints a command to stdout and then executes it
# Arguments:   command with arguments
# Returns:     the return value of the command
echo_and_perform() {
	cat << EOF
$@
EOF
	"$@"
}

# Description: Get the contents of a variable with a specific name,
#              but don't expand it. (evalVar does expand it)
#              Use this instead of 'eval', so that you won't have to
#              worry about escaping.
#              NB. this function only works on global variables.
# Arguments:   $1 - the name of the variable
# Returns:     0
# Prints:      the value of the variable
getVar() {
	local RESULT
	eval RESULT=\$$1
	cat << EOF
$RESULT
EOF
}

# Description: Get the contents of a variable with a specific name,
#              and expand it. (getVar doesn't expand it)
#              Use this instead of 'eval', so that you won't have to
#              worry about escaping.
#              NB. this function only works on global variables.
# Arguments:   $1 - the name of the variable
# Returns:     0
# Prints:      the value of the variable
evalVar() {
	local RESULT
	eval RESULT=\$$1
	eval RESULT=\""$RESULT"\"
	cat << EOF
$RESULT
EOF
}

# Description: read text from stdin to use as a c file to compile
# Arguments:   $1 - CFLAGS to use for compilation (optional)
#              $2 - LDFLAGS to use for linking (optional)
# Returns:     0 - if compile successful
#              something else - if compile failed
try_compile_c() {
	if [ -z "$COMPILE" ]; then
		echo "Fatal: Program \$COMPILE is not defined!" >&2
		exit 1
	fi
	cat > "$TEMPFILE.c"
	echo_and_perform $COMPILE $1 $2 "$TEMPFILE.c" \
			-o "$TEMPFILE.out" >> "$BUILDLOG" 2>&1
	RESULT=$?
	if [ $RESULT -ne 0 ]; then
		echo "Failed program was:" >> "$BUILDLOG"
		echo "+++ START $TEMPFILE.c" >> "$BUILDLOG"
		cat "$TEMPFILE.c" >> "$BUILDLOG"
		echo "+++ END $TEMPFILE.c" >> "$BUILDLOG"
	fi
	rm -f "$TEMPFILE.c" "$TEMPFILE.out"
	echo >> "$BUILDLOG"
	return $RESULT
}

# Description: read text from stdin to use as a c file to compile
# Arguments:   $1 - CFLAGS to use for compilation (optional)
#              $2 - LDFLAGS to use for linking (optional)
# Returns:     -1 - if compile failed
#              otherwise - exit status of the program
try_compile_and_run_c() {
	if [ -z "$COMPILE" ]; then
		echo "Fatal: Program \$COMPILE is not defined!" >&2
		exit 1
	fi
	cat > "$TEMPFILE.c"
	echo_and_perform $COMPILE $1 $2 "$TEMPFILE.c" \
			-o "$TEMPFILE.out" >> "$BUILDLOG" 2>&1
	if [ $? -ne 0 ]; then
		return -1
	fi
	rm -f -- "$TEMPFILE.c"
	"$TEMPFILE.out"
	RESULT=$?
	rm -f -- "$TEMPFILE.out"
	echo >> "$BUILDLOG"
	return $RESULT
}

# Description: Output a message to stderr, unless BUILD_SILENT is set
# Arguments: the message
build_message() {
	if [ -z "$BUILD_SILENT" ]; then
	cat >&2 << EOF
$@
EOF
	fi
}

# Description: check if a string is lexicographically before
#              another string
# Arguments:   $1 - the first string
#              $2 - the second string
# Returns:     0 if $1 is lexicographically before $2
#              1 otherwise
lexlt() {
	# The 'test' builtin in some sh shells can't do this.
	# To execute the non-builtin 'test' you need the path, and
	# that differs per system (/bin/test or /usr/bin/test).
	# It says '>=' instead of '<' because expr prints '1' for true,
	# and sh uses 0.
	return `expr "$1" ">=" "$2"`
}

# Description: try to detect a list of program dependencies.
#              This only makes sure the PROG_xxx_PRESENT flag is set.
#              It does not bail out if a dependency is not found.
#              This function is called for programs in
#              PROG_xxx_DEPEND_DETECT_PROG or LIB_xxx_DEPEND_PROG.
#              Using have_program in the respective depend functions would
#              not save the PRESENT flag, as it is executed in a subshell.
# Arguments:   $1 - the list of programs
detect_dependencies_program() {
	local PROGS PROG
	PROGS=$1
	for PROG in $PROGS; do
		have_program "$PROG"
	done
}

# Description: try to detect a list of library dependencies.
#              This only makes sure the LIB_xxx_PRESENT flag is set.
#              It does not bail out if a dependency is not found.
#              This function is called for libraries in
#              PROG_xxx_DEPEND_DETECT_LIB or LIB_xxx_DEPEND_LIB.
#              Using have_library in the respective depend functions would
#              not save the PRESENT flag, as it is executed in a subshell.
# Arguments:   $1 - the list of libaries
detect_dependencies_library() {
	local LIBS LIB
	LIBS=$1
	for LIB in $LIBS; do
		have_library "$LIB"
	done
}

# Description: check if a program is present in the path
# Arguments:   
have_program() {
	local PROG TEMP_NAME TEMP_FILE TEMP_VERSION TEMP_PRESENT TEMP_DETECT
	local TEMP_DEPEND_DETECT_PROG TEMP_DEPEND_DETECT_LIB

	PROG="$1"
	TEMP_NAME=`evalVar PROG_${PROG}_NAME`
	if [ -z "$TEMP_NAME" ]; then
		echo "Fatal: Program '$PROG' is not defined!" >&2
		exit 1
	fi
	
	eval TEMP_PRESENT="\$PROG_${PROG}_PRESENT"
	if [ -n "$TEMP_PRESENT" ]; then
		return "$TEMP_PRESENT"
	fi

	TEMP_DETECT=`evalVar PROG_${PROG}_DETECT`	
	if [ -n "$TEMP_DETECT" ]; then
		TEMP_DEPEND_PROG=`evalVar PROG_${PROG}_DEPEND_DETECT_PROG`
		TEMP_DEPEND_LIB=`evalVar PROG_${PROG}_DEPEND_DETECT_LIB`
		detect_dependencies_program "$TEMP_DEPEND_PROG"
		detect_dependencies_library "$TEMP_DEPEND_LIB"
		$TEMP_DETECT
		# NB. TEMP_DETECT should make sure PROG_${PROG}_VERSION and
                # PROG_${PROG}_FILE are set.
		if [ $? -ne 0 ]; then
			eval "PROG_${PROG}_PRESENT"=1
			build_message "$TEMP_NAME not found."
			return 1
		fi
	fi

	TEMP_FILE=`evalVar PROG_${PROG}_FILE`

	type "${TEMP_FILE%% *}" > /dev/null 2>&1
	if [ $? -ne 0 ]; then
		eval "PROG_${PROG}_PRESENT"=1
		build_message "$TEMP_NAME not found."
		return 1
	fi

	if [ $# -gt 1 ]; then
		# Minimum version supplied
		TEMP_VERSION=`evalVar PROG_${PROG}_VERSION`
		if [ -z "$TEMP_VERSION" ]; then
			eval "PROG_${PROG}_PRESENT"=1
			echo "Fatal: Could not determine version of $TEMP_NAME" >&2
			exit 1
		fi
		if lexlt "$TEMP_VERSION" "$2" ; then
			eval "PROG_${PROG}_PRESENT"=1
			build_message "Found version $TEMP_VERSION of $TEMP_NAME, \
but version $2 is required!"
			return 1
		fi
		eval "PROG_${PROG}_PRESENT"=0
		build_message "$TEMP_NAME version $TEMP_VERSION found."
		return 0
	fi

	eval "PROG_${PROG}_PRESENT"=0
	build_message "$TEMP_NAME found."
	return 0
}

# Description: check if a library is present on the system
# Arguments:   $1 - The name of the library as used in config_proginfo after
#                   "LIB_"
#              $2 - (optional) minimum version required
# Pre:         variables LIB_${1}_NAME, LIB_${1}_CFLAGS, and
#              LIB_${1}_LDFLAGS are expected to exist. If two arguments are
#              supplied, so is LIB_${1}_VERSION.
# Returns:     0 - if the library is found
#              1 - if the library is not found
have_library() {
	local LIB TEMP_NAME TEMP_PRESENT TEMP_LDFLAGS TEMP_CFLAGS \
			TEMP_VERSION TEMP_DETECT
	local TEMP_DEPEND_DETECT_PROG TEMP_DEPEND_DETECT_LIB

	LIB="$1"
	TEMP_NAME=`evalVar LIB_${LIB}_NAME`
	if [ -z "$TEMP_NAME" ]; then
		echo "Fatal: Library '$LIB' is not defined!" >&2
		exit 1
	fi

	eval TEMP_PRESENT="\$LIB_${LIB}_PRESENT"
	if [ -n "$TEMP_PRESENT" ]; then
		return "$TEMP_PRESENT"
	fi
	
	TEMP_DETECT=`evalVar LIB_${LIB}_DETECT`
	if [ -n "$TEMP_DETECT" ]; then
		$TEMP_DETECT
		TEMP_DEPEND_PROG=`evalVar LIB_${LIB}_DEPEND_DETECT_PROG`
		TEMP_DEPEND_LIB=`evalVar LIB_${LIB}_DEPEND_DETECT_LIB`
		detect_dependencies_program "$TEMP_DEPEND_PROG"
		detect_dependencies_library "$TEMP_DEPEND_LIB"
		# NB. TEMP_DETECT should make sure PROG_$LIB_VERSION is set.
		# return value of $TEMP_DETECT is used below.
	else
		TEMP_CFLAGS=`evalVar LIB_${LIB}_CFLAGS`
		TEMP_LDFLAGS=`evalVar LIB_${LIB}_LDFLAGS`

		try_compile_c "$TEMP_CFLAGS" "$TEMP_LDFLAGS" << EOF
int main(int argc, char *argv[]) {
	(void) argc;  /* Get rid of unused variable warning */
	(void) argv;  /* Get rid of unused variable warning */
	return 0;
}
EOF
	fi  # TEMP_DETECT not defined
	
	if [ $? -ne 0 ]; then
		eval "LIB_${LIB}_PRESENT"=1
		build_message "$TEMP_NAME not found."
		return 1
	fi

	if [ $# -gt 1 ]; then
		# Minimum version supplied
		TEMP_VERSION=`evalVar LIB_${LIB}_VERSION`
		if [ -z "$TEMP_VERSION" ]; then
			eval "LIB_${LIB}_PRESENT"=1
			echo "Fatal: Could not determine version of $TEMP_NAME" >&2
			exit 1
		fi
		if lexlt "$TEMP_VERSION" "$2" ; then
			eval "LIB_${LIB}_PRESENT"=1
			build_message "Found version $TEMP_VERSION of $TEMP_NAME, \
but version $2 is required"
			return 1
		fi
		eval "LIB_${LIB}_PRESENT"=0
		build_message "$TEMP_NAME version $TEMP_VERSION found."
		return 0
	fi

	eval "LIB_${LIB}_PRESENT"=0
	build_message "$TEMP_NAME found."
	return 0
}

# Description: check if a library is present on the system.
#              If it is, add the appropriate flags to CFLAGS and LDFLAGS.
#              If not, bail out.
# Arguments:   $1 - The name of the library as used in config_proginfo after
#                   "LIB_"
#              $2 - (optional) minimum version required
# Pre:         variables LIB_${1}_NAME, LIB_${1}_CFLAGS, and
#              LIB_${1}_LDFLAGS are expected to exist. If two arguments are
#              supplied, so is LIB_${1}_VERSION.
use_library() {
	local TEMP_CFLAGS TEMP_LDFLAGS
	have_library "$@"
	[ $? -eq 0 ] || exit 1

	TEMP_CFLAGS=`evalVar LIB_${1}_CFLAGS`
	TEMP_LDFLAGS=`evalVar LIB_${1}_LDFLAGS`
	CFLAGS="$CFLAGS $TEMP_CFLAGS"
	LDFLAGS="$LDFLAGS $TEMP_LDFLAGS"
	return 0
}

# Description: check if a symbol is defined
# Arguments:   $1 - the name of the symbol
#              $2 - the C code that does the actual checking
have_symbol_generic() {
	local CODE DETECT EXTRA

	DETECT=`evalVar SYMBOL_${1}_DETECT`
	if [ -n "$DETECT" ]; then
		$DETECT
		return $?
	fi

	EXTRA=`evalVar SYMBOL_${1}_EXTRA`
	CODE=`evalVar SYMBOL_${1}_CODE`
	if [ -z "$CODE" ]; then
		CODE=$2
	fi

	try_compile_c "$TEMP_CFLAGS" "$TEMP_LDFLAGS" << EOF > /dev/null 2>&1
#include <sys/types.h>
$EXTRA

$CODE
EOF
}

# Description: check if a symbol is defined.
# Arguments:   $1 - the name of the symbol
have_symbol() {
	local SYMBOL CODE
	SYMBOL="$1"

	CODE=`cat << EOF	
int main(void) {
	(void) $SYMBOL;
	return 0;
}
EOF
`

	have_symbol_generic "$SYMBOL" "$CODE"
	if [ $? -gt 0 ]; then
		build_message "Symbol '$SYMBOL' not found."
		return 1
	fi
	build_message "Symbol '$SYMBOL' found."
	return 0
}

# Description: check if a type is present.
# Arguments:   $1 - the name of the symbol
have_type() {
	local TYPE
	TYPE="$1"

	CODE=`cat << EOF	
int main(void) {
	$TYPE var;
	(void) var;
	return 0;
}
EOF
`

	have_symbol_generic "$TYPE" "$CODE"
	if [ $? -gt 0 ]; then
		build_message "Type '$TYPE' not found."
		return 1
	fi
	build_message "Type '$TYPE' found."
	return 0
}

# Description: check if a symbol is defined.
#              set HAVE_<NAME> accordingly, where <NAME> is the capitalized
#              name of the symbol.
# Arguments:   $1 - the name of the symbol
define_have_symbol() {
	local NAME VALUE
	NAME=`$TR "[:lower:]" "[:upper:]" << EOF
$1
EOF
`
	if have_symbol "$1"; then
		add_symbol "HAVE_$NAME" "#define HAVE_$NAME"
		add_symbol "HAVE_${NAME}_FLAG" 1
	else
		add_symbol "HAVE_$NAME" "#undef HAVE_$NAME"
		add_symbol "HAVE_${NAME}_FLAG" 0
	fi
}

# Description: check if a type is present.
#              set HAVE_<NAME> accordingly, where <NAME> is the capitalized
#              name of the symbol.
# Arguments:   $1 - the name of the symbol
define_have_type() {
	local NAME VALUE
	NAME=`$TR "[:lower:]" "[:upper:]" << EOF
$1
EOF
`
	if have_type "$1"; then
		add_symbol "HAVE_$NAME" "#define HAVE_$NAME"
		add_symbol "HAVE_${NAME}_FLAG" 1
	else
		add_symbol "HAVE_$NAME" "#undef HAVE_$NAME"
		add_symbol "HAVE_${NAME}_FLAG" 0
	fi
}

# Description: check if a header is available.
# Arguments:   $1 - the name of the header file
have_header() {
	local HEADER NAME EXTRA
	HEADER="$1"

	NAME=${HEADER%.h}
	EXTRA=`evalVar HEADER_${NAME}_EXTRA`

	try_compile_c "$TEMP_CFLAGS" "$TEMP_LDFLAGS" << EOF > /dev/null 2>&1
$EXTRA
#include <$HEADER>
int main() {
	return 0;
}
EOF
	if [ $? -gt 0 ]; then
		build_message "Header '$HEADER' not found."
		return 1
	fi
	build_message "Header '$HEADER' found."
	return 0
}

# Description: check if a header is available.
#              set HAVE_<NAME> accordingly, where <NAME> is the capitalized
#              name of the header file. "sys/time.h" becomes "SYS_TIME_H".
# Arguments:   $1 - the name of the symbol
define_have_header() {
	local NAME VALUE
	NAME=`$TR /.[:lower:] __[:upper:] << EOF
$1
EOF
`
	if have_header "$1"; then
		add_symbol "HAVE_$NAME" "#define HAVE_$NAME"
		add_symbol "HAVE_${NAME}_FLAG" 1
	else
		add_symbol "HAVE_$NAME" "#undef HAVE_$NAME"
		add_symbol "HAVE_${NAME}_FLAG" 0
	fi
}

# Description: Add a symbol to be replaced by substitute_vars
#              $HAVE_SYMBOLS will contain the variable names of all
#              symbols added by define_have_symbol and should be passed to
#              substitute_vars for the file you want them in.
# Arguments:   $1 - the symbol to add
#              $2 - the value of the symbol
add_symbol() {
	local NAME

	eval NAME="$1"
	eval "$NAME"=\"\$2\"
	HAVE_SYMBOLS="$HAVE_SYMBOLS $NAME"
}

check_endianness() {
	try_compile_and_run_c << EOF
int main() {
	int i;

	i = 1;
	return *((unsigned char *) &i);
}
EOF
	if [ $? -eq 0 ]; then
		build_message "Big-endian machine."
		add_symbol WORDS_BIGENDIAN "#define WORDS_BIGENDIAN"
		add_symbol "WORDS_BIGENDIAN_FLAG" 1
	else
		build_message "Little-endian machine."
		add_symbol WORDS_BIGENDIAN "#undef WORDS_BIGENDIAN"
		add_symbol "WORDS_BIGENDIAN_FLAG" 0
	fi
}


# Description: If pkg-config is installed, check if there's a pkg-config
#              entry for some binary dependency.
#              If successful, it sets the appropriate BIN_xxx_VERSION.
# Arguments:   $1 - The name of the program as it is known in
#                   config_proginfo after "BIN_"
#              $2 - The name of the dependency as it would be known to
#                   pkg-config.
try_pkgconfig_prog() {
	have_program pkgconfig || return 1

	local PROG PKG_NAME TEMP_NAME
	PROG=$1
	PKG_NAME=$2

	TEMP_NAME=`evalVar PROG_${PROG}_NAME`
	if [ -z "$TEMP_NAME" ]; then
		echo "Fatal: Program '$PROG' is not defined!" >&2
		exit 1
	fi

	if $PROG_pkgconfig_FILE --exists "$PKG_NAME"; then
		local TEMP_VERSION
		TEMP_VERSION=$($PROG_pkgconfig_FILE --modversion "$PKG_NAME")
		eval PROG_${PROG}_VERSION=\$TEMP_VERSION
		return 0
	else
		return 1
	fi
}


# Description: If pkg-config is installed, check if there's a pkg-config
#              entry for some dependency.
#              If successful, it sets the appropriate LIB_xxx_VERSION,
#              LIB_xxx_CFLAGS and LIB_xxx_LDFLAGS.
# Arguments:   $1 - The name of the library as it is known in
#                   config_proginfo after "LIB_"
#              $2 - The name of the dependency as it would be known to
#                   pkg-config.
try_pkgconfig_lib() {
	have_program pkgconfig || return 1

	local LIB PKG_NAME TEMP_NAME
	LIB=$1
	PKG_NAME=$2

	TEMP_NAME=`evalVar LIB_${LIB}_NAME`
	if [ -z "$TEMP_NAME" ]; then
		echo "Fatal: Library '$LIB' is not defined!" >&2
		exit 1
	fi

	if $PROG_pkgconfig_FILE --exists "$PKG_NAME"; then
		local TEMP_VERSION TEMP_CFLAGS TEMP_LDFLAGS
		TEMP_VERSION=$($PROG_pkgconfig_FILE --modversion "$PKG_NAME")
		TEMP_CFLAGS=$($PROG_pkgconfig_FILE --cflags "$PKG_NAME")
		TEMP_LDFLAGS=$($PROG_pkgconfig_FILE --libs "$PKG_NAME")
		eval LIB_${LIB}_VERSION=\$TEMP_VERSION
		eval LIB_${LIB}_CFLAGS=\$TEMP_CFLAGS
		eval LIB_${LIB}_LDFLAGS=\$TEMP_LDFLAGS
		return 0
	else
		return 1
	fi
}


# Description: substitute variables in files.
#              Every supplied variable name found between @'s in the
#              supplied files, is replaced by its value.
# Arguments:   $1 - The name of the variable which contains a list of
#                   variables to substitute in the files.
#              $2 - The name of the variable which contains a list of
#                   files to substitute variables in.
#                   If a filename ends on .in, that filename is used as
#                   source, and the filename without .in as target.
#                   If a filename doesn't end on .in, that filename is used
#                   as target, and the filename with .in attached as source.
#              $3 - A path to which the input file names are relative
#              $4 - A path to which the output file names are relative
substitute_vars() {
	local VARS VAR VALUE FILES FILE SRC_PATH DST_PATH

	eval VARS=\"\$$1\"
	eval FILES=\"\$$2\"
	SRC_PATH="$3"
	DST_PATH="$4"

	for VAR in $VARS; do
		# Escape all / in VAR so that we can use / as seperator char for sed
		eval VALUE=\"\$$VAR\"
		VALUE=$(echo "$VALUE" | $SED 's,\([\&/]\),\\\1,g')
		cat << EOF
s/@${VAR}@/${VALUE}/g
EOF
	done > "${TEMPFILE}.sed"

	for FILE in $FILES; do
		FILE="${FILE%.in}"
		cp -p -- "$SRC_PATH/$FILE".in "$DST_PATH/$FILE"
				# The copy is done so that the file modes are equal.
		$SED -f "${TEMPFILE}.sed" < "$SRC_PATH/$FILE".in > "$DST_PATH/$FILE"
	done
	rm -- "${TEMPFILE}.sed"
}



# Include information about programs we can detect
. build/unix/config_proginfo

# Some initialisations
HAVE_SYMBOLS=""

config_requirements() {
	# Requirements for the config program itself
	have_program echon || exit 1
	ECHON="$PROG_echon_FILE"
	have_program sed || exit 1
	SED="$PROG_sed_FILE"
	have_program tr || exit 1
	TR="$PROG_tr_FILE"
	have_program make || exit 1
	MAKE="$PROG_make_FILE"
}


